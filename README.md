[![Carthage compatible](https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat)](https://github.com/Carthage/Carthage)

#US2MapperKit

Inspired by [CSMapper](https://github.com/marcammann/CSMapper) and [Mogenerator](https://github.com/rentzsch/mogenerator), US2MapperKit is an an extremely lightweight mapping framework designed specifically for Swift 1.2, and Swift 2.0.

Unlike the past frameworks, where an object model is manually created by the developer, then retrofitted with a mapping framework at a later point, US2MapperKit takes a mapping first approach. By mapping against dictionary data up front, US2MapperKit generates the model objects based on the mapping, and allows for the extensibility inspired by the [Protocol-Oriented Programming](https://developer.apple.com/videos/wwdc/2015/?id=408) talk at WWDC.

##Features

* Extremely flexible and lightweight
* Generates model objects mapped using .plists files
* Optional and non-optional properties
* Native datatype support:
	* String
	* Int
	* Double
	* Float
	* Bool
* Collection support:
	* Array<AnyObject>
	* Dictionary<String, AnyObject>
* Customatatype support for generated model objects
	* Both as single properties, and collections
* Support for default value definitions
* Custom transformations


##Core Concept

![alt tag](/readme_assets/basic_concept_image.png?raw=true)

The the simple example above demonstrates the inner workings of the US2MapperKit. When attempting to map a Person object returned in the form a dictionary, the first step is to manually generate a plist representing the data that is being returned. The plist defines properties, data types, the mapping keys associated to the response dictionary, and any transformation to be applied. Once defined, a build time script will generate two model object files representing the model mapping.

The first class generated in the diagram represents the internal `_Person.swift` class, which contains script generated property definitions, along two initializers, one required, and one fail-able. The fail-able initializer generated takes in a `Dictionary<String, AnyObject>` input value which is parsed to the model. The internal files intent is to support the framework in mapping the response data and should not be modified by the developer since the script will regenerate it every time the project is built.

The second class generated is the `Person.swift` which inherits from the internal `_Person.swift` class. This provides a means for developer to append any custom logic, properties, or implementations of protocols as needed during the development process. This class is only generated once, and will never be overwritten during the build task. Thus updating the model mapping, will not affect any logic defined in the external class.


##Basic Use

Once configured per [Installation]() instructions:

1. Create a plist model mapping and place it into, the mapping folder defined during installation.
2. Build the target, navigate to the output directory defined during the installation process, and add the files generated to the project.
3. To map data to an instance, call the fail-able initializer generated by US2MapperKit with the `Dictionary<String, AnyObject>` data to parse.

	```
let newInstance = TestModelObject(dataDictionary)
	```

##Examples

####Optional Value Types

US2Mapper supports mapping basic data types including `String`, `Int`, `Double`, `Float` and `Bool`. Let's look at a simple example for mapping basic datatypes for a `Dictionary<String, AnyObject>` response for a basic business below

**Response Dictionary**

```
{
	'business_uuid'  	 	:  9223123456754775807,
	'business_name'  		: 'UsTwo Restaurant',
	'business_rating' 	 	:  5,
	'business_longitude'  	: 40.7053319,
	'business_latitude'   	: -74.0129945,
	'business_open'    		: 1
}
```

After receiving the data dictionary, the next stage is to model the response into a class, and map it accordingly. Unlike other mapping frameworks, where the developer needs to model the object first prior to mapping the response, US2MapperKit takes care of generating the model by creating a plist mapping for a model object. Let's go ahead and create a mapping for out `Business` model object, and add it to the mapping folder configured during installation. 


**Business.plist**
<br/>

![alt tag](/readme_assets/basic data_types_business.png?raw=true  =423x347)
<br/>
For each property that US2MapperKit will generate in the final model object, first define a dictionary within the plist to represent the property. For each property at minimum we must define a **key** and a **type** entry. The **key** maps to the value of the response dictionary, and **type** defines the Swift datatype for the property.

Now that the Model Mapping is defined, and within our configured mapping folder. Perform a build **(⌘-B)**, and navigate to the configured model output folder, and add the generate files to the project. NOTE: This only has to be done once, unless the name of the Model object changes, as a developer one should not have to add the created files again, and they should change accordingly by the build script. 

From this example we'll find there is an internal `_Business.swift` file, an external `Business.swift` class that extends from the latter, and a `US2Mapper.swift`. Lets take a take a high level look at the output below.


**_Business.swift**
<br/>

```
import Foundation
import US2MapperKit

class _Business {

	var rating : Int?
	var uuid : Double?
	var longitude : Float?
	var latitude : Float?
	var open : Bool?
	var name : String?

 	required init() {...}

 	convenience init?(_ dictionary: Dictionary<String, AnyObject>) {...}
} 
```

The internal file is where all the magic happens. At a high level, it provides a required initializer, and a [Fail-able Initializer](https://developer.apple.com/swift/blog/?id=17) that takes in a `Dictionary<String, AnyObject>` to be parsed. In the case the parsing fails, the fail-able initializer will return nil. When all the properties are optional, and there are missing values in the response, the fail-able initializer will return an instance with the missing values accordingly.

**Business.swift**
<br/>

```
import Foundation

class Business : _Business {
	// Add Custom Logic Here
}
```

The external file is for custom logic, and is only generated once, and will go unchanged if there is an update to the mapping. As a developer one can add properties, methods, and implement any protocol as needed, while the internal class is only there to hold reference to the values from the response dictionary is is being passed.

####Non-Optional Value Types

If a property is non-optional, such as the **uuid** property for the Business model object, a **nonoptional** can be added to the property definition in the model mapping accordingly. Let's take a quick peak at the `Business.plist` below

**Business.plist**
<br/>

![alt tag](/readme_assets/non_optional_business.png?raw=true  =427x190)
<br/>

Once the model mapping has been updated, perform a build **(⌘-B)**, and the changes should be reflect accordingly in the internal `_Business.swift` class.

**Business.swift**
<br/>

```
import Foundation
import US2MapperKit

class _Business {

	var rating : Int?
	var longitude : Float?
	var latitude : Float?
	var open : Bool?
	var name : String?

	var uuid : Double

 	required init(_uuid : Double) {...}

 	convenience init?(_ dictionary: Dictionary<String, AnyObject>) {...}
} 
```

Once the script updated the internal file, the uuid property is now a non-optional property, and has been added to the required initializer as an input parameter. In the case the response dictionary does not contain a value for the uuid, the fail-able initializer will return nil.

####Default Values

When there is need to fallback to a default value for optional or non-optional properties, define a default value by appending **default** to the property definition in the model mapping accordingly. In the example below, if there response dictionary does not have a value for the **open** property, while mapping it will default to false.

**Business.plist**
<br/>

![alt tag](/readme_assets/default_value_example.png?raw=true  =214x105)
<br/>



####Complex Value Types

US2MapperKit's support for mapping complete types allows creating objects types as other objects generated. Let's assume in the example below that the business listing result returns a sub-dictionary for a location, and we would like to store as a Location type.

**Response Dictionary**

```
{
	'business_uuid'  	 :  9223123456754775807,
	'business_name'  	 : 'UsTwo Restaurant',
	'business_rating' 	 :  5,
	'business_location   :
		{
			'longitude' : 40.7053319,
			'latitude'  : -74.0129945
		},					
	'business_open'    	 : 1
}

```

First create a model mapping for the Location object

**Location.plist**
<br/>

![alt tag](/readme_assets/location_plist.png?raw=true  =397x134)
<br/>

Once the model mapping for a location generated a `Location` object, and it has been added to the project, update the Business object mapping by defining a location property typed as **Location**

**Business.plist**
<br/>

![alt tag](/readme_assets/business_location_example.png?raw=true  =446x172)
<br/>


When parsing the data for a `Business` object, US2MapperKit will create a `Location` instance, and will assign the resulting value to the location property of the `Business` instance before returning it :)

####Collection Types

US2MapperKit's support for mapping Dictionaries and Array when parsing a responses' collection values with ease. Let's assume in the example below that the business listing result returns an array of ratings, and we would like to store them as an Array<Int> type

**Response Dictionary**

```
{
    "business_uuid"		: 9223123456754776000,
    "business_name"		: "UsTwoRestaurant",
    "business_ratings"	: [ 5, 4, 5, 4 ],
    "business_location" : {
        "longitude" : 40.7053319,
        "latitude"  : -74.0129945
    },
    "business_open"		: 1
}
```
First update a model mapping for the Business object, by defining setting the **type** key definition to `Array`, and adding a new **collection_subtype** key to define the subtype as `Int`

**Business.plist**
<br/>

![alt tag](/readme_assets/ratings_array_example.png?raw=true  =426x192)
<br/>

When parsing the data for a `Business` object, US2MapperKit will create a parsed ratings `Array<Int>`, and will assign the resulting value to the ratings property of the `Business` instance before returning it.

This also works for Dictionaries, just by setting the **type** key to Dictionary. When parsing a dictionary, US2MapperKit will use the assigned keys in the response when setting the values in the parsed `Dictionary`. If the response is an array, and the property to be mapped is a dictionary, US2MappkerKit will use an incremental index as the key starting with zero.

Note: When parsing collections, **collection_subtype** can be any of the native value types `String`, `Int`, `Double`, `Float`, `Bool`, and or any object generated by a US2MapperKit.


####Nested Mapping

US2MapperKit's supports nested mapping for flexibility purposes. When mapping against a Dictionary, **dot** notation can be used to reference values in the response. Observe the following response. 

**Response Dictionary**

```
{
    "business_uuid"		: 9223123456754776000,
    "business_name"		: "UsTwoRestaurant",
    "business_ratings"	: [ 5, 4, 5, 4 ],
    "business_location" : {
        "longitude" : 40.7053319,
        "latitude"  : -74.0129945
    },
    "business_open"		: 1
}
```

Although the location in the dictionary is formatted to be handled as custom Location object, assume the need to directly assign the longitude, and latitude, as properties of a Business object. 

**Business.plist**
<br/>

![alt tag](/readme_assets/nested_mapping_example.png?raw=true  =238x102)
<br/>

Using the **dot** notation per example above we can easily map the values as needed with ease. 

####Custom Transforms

To perform transformations of a single or multiple values, US2MapperKit provides the ability to map multiple values from a dictionary response, and process them accordingly using the `US2TransformerProtocol`.

```
public protocol US2TransformerProtocol {
    func transformValues(inputValues : [AnyObject]?) -> AnyObject?
}
```

Transformations are great approach, especially for Date transforms by reusing the NSDateFormatter, and possibly creating attributed string and reusing NSMutableParagraphStyles. Let's observe a response with a simple user object below/

**Response Dictionary**

```
{
    "user_id"		: 9223123456754776000,
    "first_name"	: "John",
    "last_name"		: "Doe"
}
```

Let's assuming we want to store the user's full name as a single property. The transformer implementation below take in a user's first name, and last name, as an array, and transform them in a single full name property value before being returned, and assigned.


**US2TransformerProtocol Implementation**

```
public class US2FullNameValueTransformer : US2TransformerProtocol {
    public func transformValues(inputValues : [AnyObject]?) -> AnyObject? {
        var outputString : String = ""
        
        if let inputArray = inputValues as? [String] {
            for string in inputArray {
                outputString += string
                outputString += " "
            }
        }
    
        if outputString.isEmpty { return nil }
        return outputString
    }
}

```

To implement the transformer as part of the model mapping, observe how the **key** property has become an array, and takes in multiple values to transform in to a fullName property.

**User.plist**
<br/>

![alt tag](/readme_assets/transformer_fullname_example.png?raw=true  =456x182)
<br/>

Note: The order of the keys in the model mapping determines the order of the input values in the `func transformValues(inputValues : [AnyObject]?) -> AnyObject?`. 

##Installation

####Manual Install

1. Clone the [US2MapperKit](git@github.com:ustwo/US2MapperKit.git) repository 
2. Add the contents of the Source Directory to the project
3. In the Project's Root Folder create a new folder that will contain all the mapping plist files
4. In the application targets’ “Build Phases” settings tab, click the “+” icon and choose “New Run Script Phase”. Create a Run Script with the following contents:
	
	``` 
SCRIPT_LOCATION=$(find ${PODS_ROOT} -name modelgen-swift.py | head -n 1)
python $SCRIPT_LOCATION -v 0.1 -i $PROJECT_DIR/$PROJECT_NAME/Mappings/ -o $PROJECT_DIR/$PROJECT_NAME/Model/

	```
	
4. Move the newly created Run Script phase to the second listing right below the "Target Dependencies" task


####CocoaPods

1. Edit the project's podfile

	```
    pod 'US2MapperKit', :git => 'https://github.com/ustwo/US2MapperKit.git' 
	```
2. Install US2MapperKit by running

    ```
    pod install
    ```
3. In the Project's Root Folder create a new folder that will contain all the mapping plist files
4. Navigate to the application targets’ “Build Phases” settings tab, click the “+” icon and choose “New Run Script Phase”. Create a Run Script with the following contents:

	NOTE: The script below differs for installation via Carthage

	```
SCRIPT_LOCATION=$(find ${PODS_ROOT} -name modelgen-swift.py | head -n 1)
python $SCRIPT_LOCATION -v 0.1 -i $PROJECT_DIR/$PROJECT_NAME/Mappings/ -o $PROJECT_DIR/$PROJECT_NAME/Model/
	```
5. Move the newly created Run Script phase to the second listing right below the "Target Dependencies" task


####Carthage

The installation instruction below are a for OSX and iOS, follow the extra steps documented when installing for iOS.

#####Installation

1. Create/Update the a Cartfile with with the following
	
	```
#US2MapperKit
git "https://github.com/ustwo/US2MapperKit.git"
	```
2. Run `carthage update`. This will fetch dependencies into a [Carthage/Checkouts][] folder, then build each one.
3. In the application targets’ “General” settings tab, in the “Embedded Binaries” section, drag and drop each framework for use from the Carthage/Build folder on disk.
3. The project's root folder create a new folder that will contain all the mapping plist files
4. Navigate to the application targets’ “Build Phases” settings tab, click the “+” icon and choose “New Run Script Phase”. Create a Run Script with the following contents:
	
	NOTE: The script below differs for installation via Cocoapods

	```
SCRIPT_LOCATION=$(find $SRCROOT -name modelgen-swift.py | head -n 1)
python $SCRIPT_LOCATION -v 0.1 -i $PROJECT_DIR/$PROJECT_NAME/Mapping/ -o $PROJECT_DIR/$PROJECT_NAME/Model/
	```
5. Move the newly created Run Script phase to the second listing right below the "Target Dependencies" task


#####iOS Installation

1. Follow the installation instruction above. Once complete perform the next steps

2. If you have setup a carthage build task for iOS already skip to Step 5, navigate to the targets’ “Build Phases” settings tab, click the “+” icon and choose “New Run Script Phase”. Create a Run Script with the following contents:

  	```
  	/usr/local/bin/carthage copy-frameworks
  	```
  	
3. Add the paths to the frameworks you want to use under “Input Files” within the carthage build phase as follows e.g.:

	```
 	$(SRCROOT)/Carthage/Build/iOS/US2MapperKit.framework
  	
  	```

##Troubleshooting

####Debugging

It is not always feasible to know why a a failable initializer may have failed to parse a response. USMapperKit provides the ability to use a build time flag to print out failures to the console accordingly.

To enable the Debug mode, add the  **-DUS2MAPPER_DEBUG** flag to the **Other Swift Flags** in your build settings as follows.

<br>
![alt tag](/readme_assets/debug_flag.png?raw=true  =446x60)
<br/>

The resulting output in the console will resemble the following:

```
Business instance could not be parsed, missing values for the following non-optional properties:
- business_uuid

Response:
[response: {
    "business_name"		: "UsTwoRestaurant";
    "business_ratings"	: [ 5, 4, 5, 4 ];
    "business_open"		: 1;
}]

```

####Script Reference

The model building script generates the model for as part of a build task within the project. Below is a reference of the input parameters.

```
Parameter Description:
-v defines the version (currently 0.1)
-i defines the location where the plist mappings are stored (`$PROJECT_DIR/$PROJECT_NAME/Mappings`)
-o defines the output directory for the model objects (`$PROJECT_DIR/$PROJECT_NAME/Model`)
```

####Carthage Issues: Module Created by Older Version of The Compiler

This framework was designed to run with Swift 1.2 and 2.0 accordingly. When installing using Carthage, the environment needs to be pointing to the correct instance of Xcode for the module to build correctly. 

If using the **Current SDK 6.0+** (Swift 1.2) run the following command in the terminal:

```
sudo xcode-select -s /Applications/Xcode.app/Contents/Developer
```

If using the **Beta SDK 7.0+** (Swift 2.0) run the following command in the terminal:
	
```
sudo xcode-select -s /Applications/Xcode-beta.app/Contents/Developer
```

##Future Enahancements

* Mapping Inheritance
* Set Collection Type Support
* Struct and Enum Support
* Xcode Plug-in

## License

     The MIT License (MIT)  
      
     Copyright (c) 2015 ustwo studio inc (www.ustwo.com)  
      
     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:  
     
     The above copyright notice and this permission notice shall be included in all
     copies or substantial portions of the Software.  
      
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     SOFTWARE.  
